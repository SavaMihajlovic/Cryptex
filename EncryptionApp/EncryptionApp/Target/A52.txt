using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EncryptionApp.Algorithm
{
    public class A52
    {
        const uint R1MASK = 0x07FFFF; // 19 bits
        const uint R2MASK = 0x3FFFFF; // 22 bits
        const uint R3MASK = 0x7FFFFF; // 23 bits
        const uint R4MASK = 0x01FFFF; // 17 bits

        const uint R4TAP1 = 0x000400; // bit 10
        const uint R4TAP2 = 0x000008; // bit 3
        const uint R4TAP3 = 0x000080; // bit 7

        const uint R1TAPS = 0x072000; // bits 18,17,16,13
        const uint R2TAPS = 0x300000; // bits 21,20
        const uint R3TAPS = 0x700080; // bits 22,21,20,7
        const uint R4TAPS = 0x010800; // bits 16,11

        uint R1, R2, R3, R4;

        static uint Parity(uint x)
        {
            x ^= x >> 16;
            x ^= x >> 8;
            x ^= x >> 4;
            x ^= x >> 2;
            x ^= x >> 1;
            return x & 1;
        }

        uint ClockOne(uint reg, uint mask, uint taps, uint loadedBit)
        {
            uint t = reg & taps;
            reg = (reg << 1) & mask;
            reg |= Parity(t);
            reg |= loadedBit;
            return reg;
        }

        bool Majority(uint w1, uint w2, uint w3)
        {
            int sum = (w1 != 0 ? 1 : 0) + (w2 != 0 ? 1 : 0) + (w3 != 0 ? 1 : 0);
            return sum >= 2;
        }

        void Clock(bool allP, int loaded)
        {
            bool maj = Majority(R4 & R4TAP1, R4 & R4TAP2, R4 & R4TAP3);
            if (allP || ((R4 & R4TAP1) != 0) == maj)
                R1 = ClockOne(R1, R1MASK, R1TAPS, (uint)(loaded << 15));
            if (allP || ((R4 & R4TAP2) != 0) == maj)
                R2 = ClockOne(R2, R2MASK, R2TAPS, (uint)(loaded << 16));
            if (allP || ((R4 & R4TAP3) != 0) == maj)
                R3 = ClockOne(R3, R3MASK, R3TAPS, (uint)(loaded << 18));
            R4 = ClockOne(R4, R4MASK, R4TAPS, (uint)(loaded << 10));
        }

        bool GetBit()
        {
            bool topBits = (((R1 >> 18) ^ (R2 >> 21) ^ (R3 >> 22)) & 0x01) != 0;

            bool delayBit = false;
            bool nowBit = delayBit;
            delayBit = topBits ^
                       Majority(R1 & 0x8000, (~R1) & 0x4000, R1 & 0x1000) ^
                       Majority((~R2) & 0x10000, R2 & 0x2000, R2 & 0x200) ^
                       Majority(R3 & 0x40000, R3 & 0x10000, (~R3) & 0x2000);
            return nowBit;
        }

        public void KeySetup(byte[] key, uint frame)
        {
            R1 = R2 = R3 = R4 = 0;

            for (int i = 0; i < 64; i++)
            {
                Clock(true, 0);
                uint keyBit = (uint)((key[i / 8] >> (i & 7)) & 1);
                R1 ^= keyBit; R2 ^= keyBit; R3 ^= keyBit; R4 ^= keyBit;
            }

            for (int i = 0; i < 22; i++)
            {
                Clock(true, i == 21 ? 1 : 0);
                uint frameBit = (frame >> i) & 1;
                R1 ^= frameBit; R2 ^= frameBit; R3 ^= frameBit; R4 ^= frameBit;
            }

            for (int i = 0; i < 100; i++)
                Clock(false, 0);

            GetBit();
        }

        public void Run(byte[] AtoBKeyStream, byte[] BtoAKeyStream)
        {
            Array.Clear(AtoBKeyStream, 0, AtoBKeyStream.Length);
            Array.Clear(BtoAKeyStream, 0, BtoAKeyStream.Length);

            for (int i = 0; i < 114; i++)
            {
                Clock(false, 0);
                if (GetBit())
                    AtoBKeyStream[i / 8] |= (byte)(1 << (7 - (i & 7)));
            }

            for (int i = 0; i < 114; i++)
            {
                Clock(false, 0);
                if (GetBit())
                    BtoAKeyStream[i / 8] |= (byte)(1 << (7 - (i & 7)));
            }
        }

        public void Test()
        {
            byte[] key = { 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
            uint frame = 0x21;
            byte[] goodAtoB = { 0xf4, 0x51, 0x2c, 0xac, 0x13, 0x59, 0x37, 0x64, 0x46, 0x0b, 0x72, 0x2d, 0xad, 0xd5, 0x00 };
            byte[] goodBtoA = { 0x48, 0x00, 0xd4, 0x32, 0x8e, 0x16, 0xa1, 0x4d, 0xcd, 0x7b, 0x97, 0x22, 0x26, 0x51, 0x00 };

            byte[] AtoB = new byte[15];
            byte[] BtoA = new byte[15];

            KeySetup(key, frame);
            Run(AtoB, BtoA);

            bool failed = false;
            for (int i = 0; i < 15; i++)
            {
                if (AtoB[i] != goodAtoB[i] || BtoA[i] != goodBtoA[i])
                    failed = true;
            }

            Console.WriteLine(failed ? "Test failed" : "Test passed");
        }
    }
}
